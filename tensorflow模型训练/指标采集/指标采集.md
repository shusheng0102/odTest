# 参数接口

定义一个规范的接口，定时调用第三方接口获取模型推理服务级别的指标参数、Pod 级别和容器级别的性能负载指标。

### 实现思路

1. **定义接口**：使用 Python 的 `requests` 库来调用第三方接口。
2. **定时任务**：使用 `schedule` 库来实现定时调用。
3. **异常处理**：在调用第三方接口时，添加异常处理机制，以确保程序的健壮性。

### 代码示例

```python
import requests
import schedule
import time

# 定义第三方接口的 URL
THIRD_PARTY_API_URL = "https://example.com/api/metrics"

def call_third_party_api():
    try:
        # 发送 GET 请求到第三方接口
        response = requests.get(THIRD_PARTY_API_URL)
        # 检查响应状态码
        response.raise_for_status()
        # 获取响应的 JSON 数据
        metrics = response.json()
        # 打印获取到的指标数据
        print("Received metrics:", metrics)
        return metrics
    except requests.exceptions.RequestException as e:
        print(f"Error calling third - party API: {e}")
        return None

# 定义规范的接口函数
def get_metrics():
    return call_third_party_api()

# 定时任务：每 5 分钟调用一次第三方接口
schedule.every(5).minutes.do(get_metrics)

while True:
    # 运行所有待执行的定时任务
    schedule.run_pending()
    # 休眠 1 秒
    time.sleep(1)
```

### 代码解释

1. **`call_third_party_api` 函数**：

   - 该函数使用 `requests.get` 方法发送 GET 请求到第三方接口。
   - 使用 `response.raise_for_status()` 检查响应状态码，如果状态码不是 200，将抛出异常。
   - 使用 `response.json()` 方法将响应内容解析为 JSON 格式。
   - 捕获 `requests.exceptions.RequestException` 异常，处理请求过程中可能出现的错误。
2. **`get_metrics` 函数**：

   - 该函数是一个规范的接口函数，调用 `call_third_party_api` 函数获取指标数据。
3. **定时任务**：

   - 使用 `schedule.every(5).minutes.do(get_metrics)` 定义一个每 5 分钟执行一次的定时任务。
   - 在 `while True` 循环中，使用 `schedule.run_pending()` 运行所有待执行的定时任务，并使用 `time.sleep(1)` 休眠 1 秒，避免 CPU 占用过高。

### 注意事项

- 请将 `THIRD_PARTY_API_URL` 替换为实际的第三方接口 URL。
- 如果第三方接口需要身份验证，你需要在 `requests.get` 方法中添加相应的请求头或参数。
- 你可以根据实际需求调整定时任务的时间间隔。


# 接口函数中添加参数



为了在接口函数中添加参数，以便根据不同的需求获取特定的指标数据，你可以对之前的代码进行修改。以下是具体的实现步骤和示例代码：

### 实现思路

1. **修改接口函数**：在 `get_metrics` 函数中添加参数，用于指定需要获取的指标类型。
2. **传递参数到第三方接口**：将这些参数添加到请求的 URL 中，以便第三方接口根据这些参数返回特定的指标数据。

### 代码示例

```python
import requests
import schedule
import time

# 定义第三方接口的基本 URL
THIRD_PARTY_API_BASE_URL = "https://example.com/api/metrics"

def call_third_party_api(params=None):
    try:
        # 发送 GET 请求到第三方接口，并传递参数
        response = requests.get(THIRD_PARTY_API_BASE_URL, params=params)
        # 检查响应状态码
        response.raise_for_status()
        # 获取响应的 JSON 数据
        metrics = response.json()
        # 打印获取到的指标数据
        print("Received metrics:", metrics)
        return metrics
    except requests.exceptions.RequestException as e:
        print(f"Error calling third - party API: {e}")
        return None

# 定义规范的接口函数，添加参数
def get_metrics(metric_type=None, pod_name=None, container_name=None):
    # 构建请求参数
    params = {}
    if metric_type:
        params['metric_type'] = metric_type
    if pod_name:
        params['pod_name'] = pod_name
    if container_name:
        params['container_name'] = container_name
    return call_third_party_api(params)

# 定时任务：每 5 分钟调用一次第三方接口
schedule.every(5).minutes.do(get_metrics, metric_type='model_inference', pod_name='example-pod', container_name='example-container')

while True:
    # 运行所有待执行的定时任务
    schedule.run_pending()
    # 休眠 1 秒
    time.sleep(1)

```

### 代码解释

1. **`call_third_party_api` 函数**：

   - 该函数新增了一个 `params` 参数，用于接收请求的参数。
   - 使用 `requests.get` 方法发送 GET 请求时，将 `params` 参数传递给该方法，`requests` 库会自动将这些参数添加到 URL 的查询字符串中。
2. **`get_metrics` 函数**：

   - 新增了三个参数：`metric_type`、`pod_name` 和 `container_name`，用于指定需要获取的指标类型、Pod 名称和容器名称。
   - 在函数内部，根据这些参数构建一个字典 `params`，并将其传递给 `call_third_party_api` 函数。
3. **定时任务**：

   - 在调用 `schedule.every(5).minutes.do` 时，传递了具体的参数值，例如 `metric_type='model_inference'`、`pod_name='example-pod'` 和 `container_name='example-container'`，这样每次定时任务执行时，都会根据这些参数获取特定的指标数据。

### 注意事项

- 请将 `THIRD_PARTY_API_BASE_URL` 替换为实际的第三方接口基本 URL。
- 确保第三方接口支持通过查询字符串传递参数，并且参数名和格式与代码中一致。
- 你可以根据实际需求调整 `get_metrics` 函数的参数和定时任务传递的参数值。


# 定时任务的设计


要确保 Python 中定时任务的准确性和稳定性，可以从多个方面进行优化，以下是一些具体的建议和方法：

### 选择合适的定时任务库

不同的定时任务库在功能和性能上有所差异，选择合适的库能为定时任务的准确性和稳定性奠定基础。

#### `schedule` 库

- **优点**：简单易用，提供了直观的 API 来定义定时任务，适合简单的定时需求。
- **缺点**：基于单线程运行，在任务执行时间较长时可能影响后续任务的执行时间。

```python
import schedule
import time

def job():
    print("This is a scheduled job.")

schedule.every(5).minutes.do(job)

while True:
    schedule.run_pending()
    time.sleep(1)
```

#### `APScheduler` 库

- **优点**：功能强大，支持多种调度方式（如固定间隔、定时点、循环等），支持多线程和多进程执行任务，能更好地处理复杂的定时需求。
- **缺点**：相对复杂，学习成本较高。

```python
from apscheduler.schedulers.blocking import BlockingScheduler

def job():
    print("This is a scheduled job.")

scheduler = BlockingScheduler()
scheduler.add_job(job, 'interval', minutes=5)
scheduler.start()
```

### 优化任务执行逻辑

确保任务本身的执行时间不会过长，避免影响后续任务的调度。

#### 异步执行耗时任务

如果任务中包含网络请求、文件读写等耗时操作，可以使用异步编程的方式执行，避免阻塞主线程。以 `asyncio` 结合 `APScheduler` 为例：

```python
import asyncio
from apscheduler.schedulers.asyncio import AsyncIOScheduler

async def async_job():
    print("Starting async job...")
    await asyncio.sleep(2)  # 模拟耗时操作
    print("Async job finished.")

scheduler = AsyncIOScheduler()
scheduler.add_job(async_job, 'interval', seconds=10)
scheduler.start()

try:
    asyncio.get_event_loop().run_forever()
except (KeyboardInterrupt, SystemExit):
    pass
```

#### 任务超时处理

为任务设置超时时间，避免任务无限期阻塞。可以使用 `asyncio` 的 `asyncio.wait_for` 函数实现：

```python
import asyncio

async def long_running_task():
    await asyncio.sleep(10)  # 模拟长时间运行的任务
    return "Task completed"

async def main():
    try:
        result = await asyncio.wait_for(long_running_task(), timeout=5)
        print(result)
    except asyncio.TimeoutError:
        print("Task timed out.")

asyncio.run(main())
```

### 处理异常和错误

在任务执行过程中，可能会出现各种异常，如网络错误、文件读写错误等，需要对这些异常进行捕获和处理，避免任务因异常而终止。

```python
from apscheduler.schedulers.blocking import BlockingScheduler

def job():
    try:
        # 任务逻辑
        print("Running job...")
    except Exception as e:
        print(f"Job failed: {e}")

scheduler = BlockingScheduler()
scheduler.add_job(job, 'interval', minutes=5)
scheduler.start()
```

### 系统资源管理

确保系统有足够的资源来执行定时任务，避免因资源不足导致任务执行不稳定。

#### 监控系统资源

可以使用系统监控工具（如 `top`、`htop` 等）监控 CPU、内存、磁盘 I/O 等资源的使用情况，及时发现并解决资源瓶颈问题。

#### 合理分配资源

如果定时任务需要大量的计算资源，可以考虑将任务分布到多个服务器或容器中执行，避免单个节点资源过载。

### 时间同步

确保服务器的系统时间准确，避免因时间偏差导致定时任务执行不准确。

#### 使用 NTP 服务

在 Linux 系统中，可以使用 NTP（Network Time Protocol）服务来同步系统时间。安装并配置 NTP 服务：

```bash
sudo apt-get install ntp
sudo systemctl start ntp
sudo systemctl enable ntp
```

### 日志记录和监控

记录任务的执行情况和错误信息，方便后续排查问题和监控任务的运行状态。

#### 日志记录

使用 Python 的 `logging` 模块记录任务的执行情况：

```python
import logging
from apscheduler.schedulers.blocking import BlockingScheduler

logging.basicConfig(level=logging.INFO)

def job():
    logging.info("Running job...")

scheduler = BlockingScheduler()
scheduler.add_job(job, 'interval', minutes=5)
scheduler.start()
```

#### 监控任务状态

可以使用监控工具（如 Prometheus、Grafana 等）监控定时任务的执行状态，及时发现任务异常并进行处理。


# 添加日志


在定时任务中添加日志记录可以帮助你监控任务的执行情况、排查问题。以下分别以 `schedule` 库和 `APScheduler` 库为例，展示如何在定时任务里添加日志记录。

### 使用 `schedule` 库添加日志记录

`schedule` 是一个简单易用的定时任务库，下面是添加日志记录的示例代码：

```python
import schedule
import time
import logging

# 配置日志记录
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("schedule_task.log"),
        logging.StreamHandler()
    ]
)

def job():
    try:
        logging.info("Job started.")
        # 模拟任务执行
        print("This is a scheduled job.")
        logging.info("Job completed successfully.")
    except Exception as e:
        logging.error(f"Job failed: {e}", exc_info=True)

# 定义定时任务，每 5 分钟执行一次
schedule.every(5).minutes.do(job)

while True:
    schedule.run_pending()
    time.sleep(1)
```

#### 代码解释

1. **日志配置**：使用 `logging.basicConfig` 配置日志记录，设置日志级别为 `INFO`，指定日志格式，同时将日志输出到文件 `schedule_task.log` 和控制台。
2. **任务函数**：在 `job` 函数中，使用 `logging.info` 记录任务开始和完成的信息，使用 `logging.error` 记录任务执行过程中出现的异常。
3. **定时任务**：使用 `schedule.every(5).minutes.do(job)` 定义每 5 分钟执行一次的定时任务。

### 使用 `APScheduler` 库添加日志记录

`APScheduler` 功能更强大，支持多种调度方式，以下是添加日志记录的示例代码：

```python
import logging
from apscheduler.schedulers.blocking import BlockingScheduler

# 配置日志记录
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("apscheduler_task.log"),
        logging.StreamHandler()
    ]
)

def job():
    try:
        logging.info("Job started.")
        # 模拟任务执行
        print("This is a scheduled job.")
        logging.info("Job completed successfully.")
    except Exception as e:
        logging.error(f"Job failed: {e}", exc_info=True)

# 创建调度器
scheduler = BlockingScheduler()
# 添加定时任务，每 5 分钟执行一次
scheduler.add_job(job, 'interval', minutes=5)
# 启动调度器
try:
    logging.info("Scheduler started.")
    scheduler.start()
except (KeyboardInterrupt, SystemExit):
    logging.info("Scheduler stopped.")
```

#### 代码解释

1. **日志配置**：同样使用 `logging.basicConfig` 配置日志记录，将日志输出到文件 `apscheduler_task.log` 和控制台。
2. **任务函数**：`job` 函数中使用日志记录任务的开始、完成情况以及可能出现的异常。
3. **调度器操作**：创建 `BlockingScheduler` 调度器，添加定时任务，启动调度器，并在启动和停止时记录相应的日志信息。

通过以上两种方式，你可以在定时任务中方便地添加日志记录，从而更好地监控和管理任务。



在 Python 的日志记录中添加时间戳是很常见的需求，时间戳能帮助你清晰地了解每个日志事件发生的具体时间。在前面的示例基础上，其实已经通过 `logging.basicConfig` 中的 `format` 参数添加了时间戳。下面详细解释并给出不同场景下添加时间戳的示例。

### 使用 `logging.basicConfig` 配置时间戳

`logging.basicConfig` 是 Python 中用于快速配置日志记录的函数，你可以通过设置 `format` 参数来添加时间戳。以下是具体示例：

```python
import logging
import schedule
import time

# 配置日志记录，添加时间戳
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("schedule_task_with_timestamp.log"),
        logging.StreamHandler()
    ]
)

def job():
    try:
        logging.info("Job started.")
        # 模拟任务执行
        print("This is a scheduled job.")
        logging.info("Job completed successfully.")
    except Exception as e:
        logging.error(f"Job failed: {e}", exc_info=True)

# 定义定时任务，每 5 分钟执行一次
schedule.every(5).minutes.do(job)

while True:
    schedule.run_pending()
    time.sleep(1)

```

#### 代码解释

- `format='%(asctime)s - %(levelname)s - %(message)s'`：
  - `%(asctime)s` 是一个日志格式化占位符，它会被替换为日志记录时的时间戳。
  - `%(levelname)s` 表示日志的级别（如 `INFO`、`ERROR` 等）。
  - `%(message)s` 表示具体的日志消息内容。

### 自定义时间戳格式

你还可以通过 `datefmt` 参数自定义时间戳的格式。例如：

```python
import logging
import schedule
import time

# 配置日志记录，自定义时间戳格式
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S',
    handlers=[
        logging.FileHandler("schedule_task_custom_timestamp.log"),
        logging.StreamHandler()
    ]
)

def job():
    try:
        logging.info("Job started.")
        # 模拟任务执行
        print("This is a scheduled job.")
        logging.info("Job completed successfully.")
    except Exception as e:
        logging.error(f"Job failed: {e}", exc_info=True)

# 定义定时任务，每 5 分钟执行一次
schedule.every(5).minutes.do(job)

while True:
    schedule.run_pending()
    time.sleep(1)

```

#### 代码解释

- `datefmt='%Y-%m-%d %H:%M:%S'`：指定了时间戳的格式为 `年-月-日 时:分:秒`。你可以根据自己的需求调整时间戳的格式，例如 `%Y/%m/%d %I:%M:%S %p` 会显示为 `2024/12/31 03:30:00 PM` 这样的格式。

### 使用 `APScheduler` 时添加时间戳

当使用 `APScheduler` 时，添加时间戳的方式和上面类似，以下是示例：

```python
import logging
from apscheduler.schedulers.blocking import BlockingScheduler

# 配置日志记录，添加时间戳
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("apscheduler_task_with_timestamp.log"),
        logging.StreamHandler()
    ]
)

def job():
    try:
        logging.info("Job started.")
        # 模拟任务执行
        print("This is a scheduled job.")
        logging.info("Job completed successfully.")
    except Exception as e:
        logging.error(f"Job failed: {e}", exc_info=True)

# 创建调度器
scheduler = BlockingScheduler()
# 添加定时任务，每 5 分钟执行一次
scheduler.add_job(job, 'interval', minutes=5)
# 启动调度器
try:
    logging.info("Scheduler started.")
    scheduler.start()
except (KeyboardInterrupt, SystemExit):
    logging.info("Scheduler stopped.")

```

通过以上方法，你可以在日志中方便地添加时间戳，并且可以根据需要自定义时间戳的格式。
